#!{{ python3_command }}
# 1. Do (dirty) backup while service is running.
# 2. Shut down service.
# 3. Do backup again.
# 4. Start service
# 5. Prune backups.
#
# Designed to run from cron.
#
# It's belongs to a certain bbclient installation so it contains paths
# hardcoded at templating time.

import sys
import shlex
import datetime
import click

from contextlib import nullcontext
from os import access, X_OK, environ, chdir
from os.path import exists, isdir, getsize
from subprocess import Popen, run, DEVNULL, CalledProcessError, STDOUT

chdir("{{ bbclient_coldbackup | mandatory }}")

# The script relies on the current directory having a certain structure.
assert exists('docker-compose.yml')
assert isdir('volumes')
assert access('{{ bbclient_all }}', X_OK)

environ['BORG_UNKNOWN_UNENCRYPTED_REPO_ACCESS_IS_OK'] = 'yes'

# If this script exists we'll run it once the project is down, e.g for doing
# log rotation etc.
DOWN_HOOK = './bbclient-down-hook'


def logfile():
    if sys.stdin.isatty():
        return nullcontext(sys.stdout)
    else:
        return open('backup.log', 'a')


def logfmt(msg):
    now = datetime.datetime.now().astimezone()
    return "=== %s %s" % (msg, now.strftime('%a %b %d %H:%M:%S %Z %Y'))


def bbclient(what, arg):
    with logfile() as log:
        print(logfmt(what), file=log, flush=True)
        run(['{{ bbclient_all }}'] + shlex.split(arg),
            check=1, stdout=log, stderr=STDOUT)

def log(msg):
    with logfile as log:
        print(logfmt(msg), file=log, flush=True)


def prune():
    bbclient('prune', 'prune --verbose --stats '
             '--keep-within 7d --keep-daily=30 --keep-weekly=150')
    # borg(1) doesn't let us remove all archives with a given prefix, so we
    # keep the last dirty one.
    bbclient('prune dirty',
             'prune -P dirty- --verbose --stats --keep-last 1')


def start_down_hook():
    p = None
    try:
        p = Popen([DOWN_HOOK])
    except FileNotFoundError:
        log("No down hook (%s)" % DOWN_HOOK)
    except OSError as e:
        log("Could not run down hook - %s" % str(e))
    else:
        log("Starting down hook", DOWN_HOOK, "in the background")
    return p


def backup(down=False, dirty=True):
    if exists('{{ bbclient_patterns_path }}'):
        patterns = '--patterns-from {{ bbclient_patterns_path }}'
    else:
        patterns = 'volumes'
    try:
        # If our docker-builds script is available then dump information about
        # currently running images. Don't care if it fails.
        run("docker-builds > volumes/build.info", shell=1, stderr=DEVNULL)

        if dirty:
            # Otherwise we're probably running from crontab and proceed as
            # usual. Dirty means that we'll take a backup while the service is
            # still running. The idea is that the cold backup will go much
            # faster.
            bbclient('dirty backup',
                     'create -x -v --stats "::dirty-{now}" %s' % patterns)
        else:
            log("Not performing dirty backup.")

        log("Bringing project down.")
        run(['docker-compose', 'down'], stderr=DEVNULL, check=1)
        hook = start_down_hook()

        bbclient('cold backup',
                 'create -x -v --stats "::{now}" %s' % patterns)
        if hook:
            hook.wait()
            log("Down hook finished with returncode ", hook.returncode)

    finally:
        if down:
            log("Not bringing project up again")
        else:
            log("Bringing project back up")
            run(['docker-compose', 'up', '-d'], stderr=DEVNULL)


@click.command()
# This option is useful when doing maintenance and wanting to do a last backup
# before upgrading the project, then it shouldn't be brought up again.
@click.option('--down', is_flag=True, help="Leave the application down.")
# Used when testing to skip the dirty backup.
@click.option('--dirty/--no-dirty', default=True)
def main(down, dirty):
    logsize = getsize('backup.log') if exists('backup.log') else 0

    try:
        backup(down, dirty)
        prune()
        log('done')
    except CalledProcessError:
        # For the sake of cron.
        if not sys.stdin.isatty():
            # In case of error, print logs created since we started.
            f = open('backup.log'); f.seek(logsize); print(f.read())  # noqa


if __name__ == '__main__':
    main()
