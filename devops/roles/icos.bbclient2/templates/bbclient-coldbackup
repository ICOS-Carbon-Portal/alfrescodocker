#!/usr/bin/python3.8
# 1. Do (dirty) backup while service is running.
# 2. Shut down service.
# 3. Do backup again.
# 4. Start service
# 5. Prune backups.
#
# Designed to run from cron.
#
# It's belongs to a certain bbclient installation so it contains paths
# hardcoded at templating time.

import sys
import shlex
import datetime
import click

from contextlib import nullcontext
from os import access, X_OK, environ, chdir
from os.path import exists, isdir, getsize
from subprocess import run, DEVNULL, CalledProcessError, STDOUT

chdir("{{ bbclient_coldbackup | mandatory }}")

# The script relies on the current directory having a certain structure.
assert exists('docker-compose.yml')
assert isdir('volumes')
assert access('{{ bbclient_all }}', X_OK)


environ['BORG_UNKNOWN_UNENCRYPTED_REPO_ACCESS_IS_OK'] = 'yes'


def logfile():
    if sys.stdin.isatty():
        return nullcontext(sys.stdout)
    else:
        return open('backup.log', 'a')


def logfmt(msg):
    now = datetime.datetime.now().astimezone()
    return "=== %s %s" % (msg, now.strftime('%a %b %d %H:%M:%S %Z %Y'))


def bbclient(what, arg):
    with logfile() as log:
        print(logfmt(what), file=log, flush=True)
        run(['{{ bbclient_all }}'] + shlex.split(arg),
            check=1, stdout=log, stderr=STDOUT)


def prune():
    bbclient('prune', 'prune --verbose --stats '
             '--keep-within 7d --keep-daily=30 --keep-weekly=150')
    # borg(1) doesn't let us remove all archives with a given prefix, so we
    # keep the last dirty one.
    bbclient('prune dirty',
             'prune -P dirty- --verbose --stats --keep-last 1')

def backup(down=False):
    if exists('{{ bbclient_patterns }}'):
        patterns = '--patterns-from {{ bbclient_patterns }}'
    else:
        patterns = 'volumes'
    try:
        # If our docker-builds script is available then dump information about
        # currently running images. Don't care if it fails.
        run("docker-builds > volumes/build.info", shell=1, stderr=DEVNULL)

        # If --down is given, we're running interactively and want to bring the
        # project down and leave it down.
        if down:
            print("bringing project down")
        else:
            # Otherwise we're probably running from crontab and proceed as
            # usual. Dirty means that we'll take a backup while the service is
            # still running. The idea is that the cold backup will go much
            # faster.
            bbclient('dirty backup',
                     'create -x -v --stats "::dirty-{now}" %s' % patterns)

        run(['docker-compose', 'down'], stderr=DEVNULL, check=1)

        bbclient('cold backup',
                 'create -x -v --stats "::{now}" %s' % patterns)
    finally:
        if down:
            print("not bringing project up again")
        else:
            run(['docker-compose', 'up', '-d'], stderr=DEVNULL)


@click.command()
# This option is useful when doing maintenance and wanting to do a last backup
# before upgrading the project, then it shouldn't be brought up again.
@click.option('--down', is_flag=True, help="Leave the application down.")
def main(down):
    logsize = getsize('backup.log') if exists('backup.log') else 0

    try:
        backup(down)
        prune()
        with logfile() as log:
            print(logfmt('done'), file=log)
    except CalledProcessError:
        # For the sake of cron.
        if not sys.stdin.isatty():
            # In case of error, print logs created since we started.
            f = open('backup.log'); f.seek(logsize); print(f.read())  # noqa


if __name__ == '__main__':
    main()
